#!/bin/bash

# Automatically selects wallpaper based on time of day
# Uses sunwait to calculate sunrise/sunset times and backgrounds.conf for mapping

BACKGROUNDS_DIR="$HOME/.config/omarchy/current/theme/backgrounds"
CONFIG_FILE="$HOME/.config/omarchy/current/theme/backgrounds.conf"
CURRENT_BACKGROUND_LINK="$HOME/.config/omarchy/current/background"

# Default location (Petaluma, CA) - overridden by config
LATITUDE="38.23N"
LONGITUDE="122.64W"

# Load config if it exists
if [[ -f "$CONFIG_FILE" ]]; then
    source "$CONFIG_FILE"
fi

# Get current time in minutes since midnight
NOW_MINUTES=$(date +%H%M | awk '{h=int($1/100); m=$1%100; print h*60+m}')

# Calculate sunrise and sunset times using sunwait
# Format: HHMM
if ! command -v sunwait &> /dev/null; then
    echo "sunwait not installed, falling back to omarchy-theme-bg-next"
    exec omarchy-theme-bg-next
    exit
fi

# Weather detection function (cached for 30 minutes)
get_weather_condition() {
    local cache_file="/tmp/omarchy-weather-cache"
    local cache_age=1800  # 30 minutes

    # Check cache freshness
    if [[ -f "$cache_file" ]] && [[ $(($(date +%s) - $(stat -c %Y "$cache_file"))) -lt $cache_age ]]; then
        cat "$cache_file"
        return 0
    fi

    # Fetch weather (5 second timeout)
    local condition=$(curl -s -m 5 "wttr.in/${CITY:-Petaluma}?format=%C" 2>/dev/null)

    if [[ -z "$condition" ]]; then
        echo "default"
        return 1
    fi

    # Normalize to clear vs cloudy
    case "${condition,,}" in  # lowercase
        *clear*|*sunny*)  echo "clear" ;;
        *)                echo "cloudy" ;;
    esac | tee "$cache_file"
}

# Get today's sunrise and sunset
SUNRISE_TIME=$(sunwait list civil "$LATITUDE" "$LONGITUDE" | awk -F', ' '{print $1}')
SUNSET_TIME=$(sunwait list civil "$LATITUDE" "$LONGITUDE" | awk -F', ' '{print $2}')

# Convert to minutes since midnight
SUNRISE_MINUTES=$(echo "$SUNRISE_TIME" | awk -F: '{print $1*60 + $2}')
SUNSET_MINUTES=$(echo "$SUNSET_TIME" | awk -F: '{print $1*60 + $2}')

# Calculate period boundaries (in minutes since midnight)
NOON_MINUTES=$((12 * 60))
DUSK_START=$((SUNSET_MINUTES - 60))
DUSK_END=$((SUNSET_MINUTES + 30))

# Determine current period
if [[ $NOW_MINUTES -ge $SUNRISE_MINUTES && $NOW_MINUTES -lt $NOON_MINUTES ]]; then
    PERIOD="MORNING"
elif [[ $NOW_MINUTES -ge $NOON_MINUTES && $NOW_MINUTES -lt $DUSK_START ]]; then
    PERIOD="AFTERNOON"
elif [[ $NOW_MINUTES -ge $DUSK_START && $NOW_MINUTES -lt $DUSK_END ]]; then
    PERIOD="DUSK"
else
    PERIOD="NIGHT"
fi

# Get wallpapers for this period from config
# For DUSK and NIGHT: use time-only (skip weather)
# For MORNING and AFTERNOON: try weather-based first, fall back to time-based
PERIOD_WALLPAPERS=""

if [[ "$PERIOD" == "DUSK" ]] || [[ "$PERIOD" == "NIGHT" ]]; then
    # Time-only periods (no weather check)
    PERIOD_VAR="${PERIOD}"
    PERIOD_WALLPAPERS="${!PERIOD_VAR}"
else
    # MORNING or AFTERNOON: try weather-based first
    WEATHER=$(get_weather_condition)

    if [[ -n "$WEATHER" ]] && [[ "$WEATHER" != "default" ]]; then
        # Weather available: try CLEAR or CLOUDY
        WEATHER_VAR="${WEATHER^^}"  # CLEAR or CLOUDY
        PERIOD_WALLPAPERS="${!WEATHER_VAR}"
    fi

    # Fall back to time-based (MORNING or AFTERNOON) if no weather variants
    if [[ -z "$PERIOD_WALLPAPERS" ]]; then
        PERIOD_VAR="${PERIOD}"
        PERIOD_WALLPAPERS="${!PERIOD_VAR}"
    fi
fi

# If no config or empty period, fall back to all wallpapers
if [[ -z "$PERIOD_WALLPAPERS" ]]; then
    mapfile -d '' -t ALL_BACKGROUNDS < <(find -L "$BACKGROUNDS_DIR" -type f -print0 | sort -z)
    if [[ ${#ALL_BACKGROUNDS[@]} -eq 0 ]]; then
        notify-send "No wallpapers found" -t 2000
        exit 1
    fi
    # Pick random wallpaper
    RANDOM_INDEX=$((RANDOM % ${#ALL_BACKGROUNDS[@]}))
    NEW_BACKGROUND="${ALL_BACKGROUNDS[$RANDOM_INDEX]}"
else
    # Convert multiline/space-separated list to array, filtering empty entries
    WALLPAPER_NAMES=()
    while IFS= read -r line; do
        # Trim whitespace and skip empty lines
        line=$(echo "$line" | xargs)
        [[ -n "$line" ]] && WALLPAPER_NAMES+=("$line")
    done <<< "$PERIOD_WALLPAPERS"

    # Build full paths
    PERIOD_BACKGROUNDS=()
    for name in "${WALLPAPER_NAMES[@]}"; do
        FULL_PATH="$BACKGROUNDS_DIR/$name"
        if [[ -f "$FULL_PATH" ]]; then
            PERIOD_BACKGROUNDS+=("$FULL_PATH")
        fi
    done

    # Pick random from period wallpapers
    if [[ ${#PERIOD_BACKGROUNDS[@]} -eq 0 ]]; then
        notify-send "No wallpapers for $PERIOD period" -t 2000
        exit 1
    fi

    RANDOM_INDEX=$((RANDOM % ${#PERIOD_BACKGROUNDS[@]}))
    NEW_BACKGROUND="${PERIOD_BACKGROUNDS[$RANDOM_INDEX]}"
fi

# Only change if different from current
CURRENT_BACKGROUND=""
if [[ -L "$CURRENT_BACKGROUND_LINK" ]]; then
    CURRENT_BACKGROUND=$(readlink "$CURRENT_BACKGROUND_LINK")
fi

# Update background symlink if changed
if [[ "$NEW_BACKGROUND" != "$CURRENT_BACKGROUND" ]]; then
    ln -nsf "$NEW_BACKGROUND" "$CURRENT_BACKGROUND_LINK"
fi

# Always restart swaybg to ensure correct background is displayed
# (Handles startup race conditions and ensures sync with current time period)
pkill -x swaybg 2>/dev/null
sleep 0.3

# Start swaybg (uwsm-app handles backgrounding via systemd scopes)
uwsm-app -- swaybg -i "$CURRENT_BACKGROUND_LINK" -m fill &

# Wait briefly for swaybg to start
sleep 0.5
